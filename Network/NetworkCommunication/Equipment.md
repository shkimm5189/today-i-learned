# 네트워크 장비

# Cable
케이블은 크게 3종류로 구분된다.
1. Crossover Cable[cross]
3
2. Straight-Through Cable[direct]

3. Lollover Cable[Console]

> 다이렉트 케이블은 같은 계층에 있는 장비끼리 연결할때, 크로스케이블은 서로 다른 계층에 있는 장비를 연결할때 사용된다.

# L1
## Hub
데이터와 신호에 대한 변환만 가능하다.
허브는 패킷이 들어온 포트를 제외하고 모든 포트로 패킷 전달.
연결된 PC수가 많아질수록 네트워크에서 충돌이 많아져 속도가 느려진다.

# L2
## Switch
- 브릿지와 스위치는 MAC 주소와 해당 장비의 포트 번호가 기록된 MAC address table을 보고 목적지에게만 Frame 전송.
- 스위치는 한 포트에서 전송되는 Frame이 MAC address table  에 있는 특정 포트로만 전송하기에 다른 포트가 전송하는 Frame과 충돌 발생하지 않음
- 스위치는 각각의 포트가 하나의 Collision domain에 있다고 표현.
## 1. 스위치
### 1.1 개념
누가 어느 위치에 있는지 파악하고 실제 통신시 자신이 알고있는 위치로 패킷을 정확하게 전송하는 것.
=> MAC주소 테이블을 가지고 있기에 가능
### 1.2 브릿지
이더넷 프레임으로 MAC줏소 테이블을 만들어 유지하고, 프레임을 전달하는 동장(1.3 참조)
### 1.3 동작
스위치 부팅 시 네트워크 관련 정도가 아무 것도 없다.
- 플러딩(Flooding)
```
Hub같이 모든 포트로 패킷을 흘리는 동작.

패킷을 전달 받으면 도착지 MAC주소를 파악하여 스위치의 MAC 주소 테이블에 있는 곳으로 전송을 한다.
MAC 주소 테이블에 해당 MAC주소가 없을 경우 모든 포트에 같은 내용의 패킷을 전송함.

why? 스위치는 LAN 환경에서 구성되기 때문에 자신이 정보를 갖고 있지 않더라도 어딘가에 장비가 있을수 있다고 가정하기때문.

플러딩은 정상적인 동작이지만 플러딩이 많아지면 스위치가 정상적인 작동을 못한다.
```
> 비정상적 플러딩 :
- 어드레스러닝(Address Learning)

```
스위치가 정상적으로 동작하려면 MAC주소 테이블이 유지되어야함.
따라서, MAC주소 테이블을 만들고 유지하는 과정을 Address Learning 이라한다.


```
>  MAC 주소 테이블 : 어느 위치(포트)에 어떤 장비(MAC 주소)가 연결되었는지에 대한 정보가 저장된 임시 테이블.
- 포워딩/필터링(Forwarding/Filtering)
```
포워딩 : 패킷이 들어왔을 경우 도착지 MAC주소를 확인하고 MAC 주소테이블과 비교하여 해당 포트로 패킷을 넘기는것을 포워딩이라한다.

필터링 : 다른 포트로 해당 패킷을 보내지 않는것을 필터링이라 한다.

포워딩과 필터링 작업은 여러 포트에서 동시에 수행 될수있다.
통신은 다른 포트에 영향을 미치지 않기에 독립적으로 동작한다.
```

- 에이징(Aging)
```
ARP 테이블과 MAC테이블은 일정한 시간동안 지워지지 않는다
-> 이 시간을 에이징 타임 이라한다. 300sec 이상 없으면 삭제

일반적으로 MAC 테이블의 에이징 타임이 단말의 ARP 에이징 타임보다 길기때문에 네트워크를 플러딩없이 운영가능.
```


---
패킷을 만들기 전에 통신 단말간에 MAC주소를 알아 내기 위해 ARP브로드캐스트가 먼저 수행 되기때문에 유니캐스트보다 ARP브로드캐스트가 먼저 네트워크에 전달
-> 이 ARP를 이용한 MAC 주소 습득돠정에서 이미 출발/목적지의 MAC주소를 습득할수있어 실제 유니캐스트 통신 시작시 이미 만들어진 MAC 테이블로 포워딩/필터링한다.

### 1.3VLAN
#### 1.3.1 VLAN 개요
- 물리적 배치와 상관 없이 LAN을 논리적으로 분할,구성하는 기술
- VLAN을 나누면 유니캐스트,브로드캐스로도 VLAN간에 통신이 불가<br>따라서, 분할된 VLAN과의 통신을 위해선 3계층 장비가 필요
- 물리적으로 다른 곳에 위치한 단말을 하나의 VALN을 사용하여 같은 네트워크로 관리 할수있음.

#### 1.3.2 VLAN 종류와 특징
#### 1.3.2.1 포트 기반 VLAN
스위치를 논리적으로 분할하여 사용 하는 것(일반적으로 사용)
#### 1.3.2.2 MAC 기반 VLAN
스위치의 고정 포트에 VLAN을 할당하는 것이 아닌 단말을 기준으로 VLAN을 할당하는 것

#### 1.3.3 VLAN모드(Trunk/Access) 동작 방식
- 같은 스위치 내에도 다른 VLAN으로 설정 되있다면 서로 통신이 불가하다.<br>
why? vlan으로 구분된 네트워크에서는 브로드캐스트인 ARP request가 다른 vlan으로 전달될수 없기에 3계층 장비가 필요<br>
vlan이 다르다는 것은 별도의 네트워크로 분할 한것 -> 네트워크가 다르고 IP 주소할당도 다른 네트워크로 할당됨.


<br>

|Access Port|Trunk(tagged) Port|
|--|--|
|일반 단말이 사용하는 포트|스위치간 태그(trunk)를 위한 포트 |
#### native vlan
트렁크 포트에는 태그를 모두 달지만 native 지정된 vlan에는 태그를 지정하지 않는다. <br>
why? 모든 vlan에 태그를 달면 스위치에서 인캡슐레이션이 계속 일어나기 때문에 속도 저하되기 때문에 하나의 태그포트에 native가 자동지정된다.
```
다른 스위치의 vlan 간에 통신을 위한 포트를 각각 지정해야한다.
ex) 2개의 스위치에 vlan 3개가 존재할경우, 각각 3개의 통신을 위한 포트를 지정 해야함.
-> vLan을 많이 사용하는 중,대형 네트워크에서는 장비간의 연결만으로 많은 포트들이 낭비된다.
```

```
vlan 설정
router 에서 할일

interface 분할 0/0.1 0/0.2
interface fa 0/0.1  // 하면 자동으로 생김



switch에서 할일
switch# show vlan		 //vlan정보는 따로 봐야함

switch# vlan 2 	//vlan 번호 지정
이름 지정 할수있음

switch# interface range fa0/1 - fa0/11  // fa0/1 부터 fa0/11가지 동시에 컨트롤
switch# switchport mode access
switch# switchport access vlan 2

//trunk port 설정
switch# int fa0/24  //24번 인터페이스 진
switch# switchport mode trunk
```






### 1.4 SWITCH 설정 (cisco)
#### 1.4.1 스위치 개요
스위치 자체에 고유한 MAC주소가 있다.
``switch> show version`` => 스위치 맥주소 확인가능

### 1.5 STP
루프를 확인하고 적절히 포트를 사용하지 못하게하여 루프를 예방하는 메커니즘.<br> 루프가 생기지 않도록 유지하는 것이 목적.

#### 1.5.1 Root SWITCH 선출

RSW(Root switch)의 스위치의 맥주소가 가장 낮은 스위치.
- Root ID 프레임을 수신한 포트
- cost가 가장 낮은 포트 (IEEE 1G=4, 100M = 19, 10M = 100)
- STP프레임(BPDU)을 전달해준 스위치의 SWITCH ID
- BPDU를 전달해준 스위치의 PORT ID
> BPDU(Bridge Protocol Data Unit) : STP에 의해 브리지 스위치간 주고받는 제어 프레임

``switch# show spanning-tree``<br>
명령어로 RSW를 찾아갈수있다. role확인 회선이 root라고 적혀있는 부분이 RSW로 가는 경로이다.

#### 1.5.2 스위치 상태 및 변경 과정
STP가 동작중인 스위치에서는 루프를 막기위해 신규 스위치가 연결되면 바로 트래픽이 흐르지 않는다.<br>
BPDU를 기다려 학습하고 구조를 파악후 트래픽을 흘리고 루프 구조인 경우 차단을 유지함.
| 상태  | 설명|
|--|--|
| BLK<br>(Blocking) | 패킷 데이터를 차단한 상태로 BPDU를 기다림.<br>총 20초동안 상대 스위치에서 BPDU를 받지 못하거나 후순위 BPDU를 받았을때 리스닝으로 변경    |
| LSN<br>(Listening) | 해당 포트가 전송 상태로 변경되는 것을 결정하고 준비<br>15초 동안 대기 |
| LRN<br>(Learning) | 이미 해당 포트를 포워딩하기로 결정하고 실제로 패킷 포워딩이 일어날때 곧바로 동작할수있게 MAC주소를 러닝함.<br>15초 동안 대기 |
| FWD<br>Forwarding |  패킷 포워딩하는 단|

> 토폴로지 변경 시 지연시간이 걸린다.

#### 1.5.3 RSTP (향상된 STP)
- 정상적인 경로에 문제가 발생했을 때 , 백업 경로를 활성화 하는데 30~50초가 걸린다. 시간이 너무 오래 걸리기때문에 RSTP가 개발됨.
- STP는 토폴로지에 관해 2개의 메세지(TCN,TCA)만 있지만 RSTP는 8개의 비트를 모두 사용하여 다양한 정보를 사용한다.

#### 명령어 설정
```
switch# conf t
switch(config)# spanning-tree mode rapid-pvst
```


# L3
## 2. 라우터

목적지의 주소가 라우팅 테이블에 존재 하지않을 경우 패킷을 버림.

### 1. 1라우터 동작
#### 1.1.1 경로 지정 - 라우팅/스위칭
라우터가 패킷을 처리 할때 크게 2가지 작업을 수행함.
- 경로 정보를 얻어 경로 정보를 정리
- 정리된 경로 정보를 기반으로 패킷을 포워딩.

#### 1.1.2 라우팅 동작과 라우팅 테이블
현대 인터넷에서는 단말의 목적지까지 경로를 모두 책임 지는것이 아니다.<br>홉-바이-홉(Hop-by-Hop): 인접한 라우터까지만 경로를 지정하고 인접한 라우터에서 다시 최적의 경로를 파악후 패킷을 포워딩한다.

인접한 라우터를 넥스트 홉(Next Hop)이라 부른다.
-> 라우터는 최적의 넥스트 홉을 선택해 전송
```
넥스트 홉 지정 방법
1. 다음 라우터의 IP를 지정하방법
2. 라우터의 나가는 인터페이스를 지정하는 방법
3. 라우터의 나가는 인터페이스와 다음 라우터의 IP를 동시에 지정하는 법
```
> 루프가 없는 3계층 : TTL(Time To Live) : TTL은 패킷이 네트워크에 살아있을수 있는 시간을 제한한다.
> 라우터(홉)을 지날때마다 TTL 값이 1씩 감소한다. 0이 되면 패킷은 소멸된다. 따라서 패킷이 무한히 네트워크에 루프되는것을 막는다.

#### 1.1.2.1 라우팅 테이블 정보
```
AD(Administrative Distance) value : 라우터에서 다수의 라우팅 프로토콜이 동작하는 경우 우선순위를 부여하는 기준.
AD값이 낮을 수록 우선순위가 높다
```
| route source            | distance |
| ----------------------- | -------- |
| connected interface     | 0        |
| static route to nexthop | 1        |
| external BGP            | 20       |
| OSPF                    | 110      |
| RIP                     | 120      |
|                         |          |


```
메트릭(Metric) : 라우팅 프로토콜들이 최적의 경로를 선택하는 기준
				메트릭은 라우팅 프로토콜 마다 다름.
```

| 라우팅 프로토콜 | 메트릭               |
| --------------- | -------------------- |
| RIP             | 홉카운트(Hop Coufnt) |
| OSPF            | cost (속도)          |
| BGP             | attribute            |


라우터가 목적지에 이르는 여러 경로 중의 최적의 경로를 결정하는데, 우선 순위의 기 준의 매길수있게 숫자로 환산하는 변수. (값이 낮을수록 우선순위 크다.)
- 라우터는 가장 적은 메트릭값을 갖는 경로를 찾게 된다.
메트릭 값이 같을 경우 : 설정 정보에 따라 경로지정(5/5 인경우. 두개의 경로 모두 사용)
> 라우팅 프로토콜 별로 다른 메트릭 값을 갖는다.

#### 1.1.2Routing (경로 정보를 얻는 법)
#### 1.1.2.1 static routing
 관리자가 목적지 네트워크와 넥스트 홉을 라우터에 직접 지정해 경로 정보를 입력하는 것.

```
cisco : ip route NETWORK SUBNETMASK NEXTHOP
route add -net NETWORK /Prefix gw NEXTHOP
```
디폴트 라우팅 :
``ip route 0.0.0.0 0.0.0.0 NextHop``<br>
서브넷 마스크가 0이라는 것은 연산 결과가 모두 0이므로 체크하지 않는 다는의미 -> **모든 네트워크** 라는 뜻이다.

> 모든 라우팅 설정을 디폴트로 하지않는 이유
> 폐쇄적인 망에서는 모든 라우터에 디폴트 라우팅을 하면 불필요한 트래픽이 생성되어 오버헤드 일으킨다.
> 내부망은 다이나믹 라우팅으로 설정하고 내부망에서 외부(인터넷)에 접속될때 디폴트 라우팅을 설정하는것이 좋다.


#### 1.1.2.2  dynamic route
 관리 해야할 라우터와 네트워크가 많아지면 스태틱  라우팅으로 구성하고 관리하기 어렵다.

다이나믹 라우팅 프로토콜 : 활성화 되어있는 모든 인터페이스로 라우팅 정보 전달.

| 분류 방법 | 분류                     | 내용                                                         | 프로토콜             |
| --------- | ------------------------ | ------------------------------------------------------------ | -------------------- |
| 역할      | EGP                      | 서로 다른 AS 간 정보교환용                                   | BGP                  |
|           | IGP                      | AS내부에 동작                                                | RIP,EIGRP,OSPF,IS-IS |
| 동작 원리 | 디스턴스 벡터            | 직접 연결된 장비가 보내준 정보를 기반으로 최적의 경로 선정   | RIP,BGP              |
|           | 링크 스테이트            | 네트워크 망에 속한 장비가 보내준 정보를 기반으로 토폴로지 맵을 만들어 SPF알고리즘을 이용해 최적의 경로 선정 | OSPF, IS-IS          |
|           | 어드벤스드 디스턴스 벡터 | 디스턴스 벡터보다 다양한 결로 선정을 위한 요소가 있으며 직접 연결된 장비를 지난 장비까지 고려해 경로 선정 |                      |

### RIP protocols 비교
디스턴스 벡터 프로토콜이며 UDP 520 port를 사용한다.

**차이점**
| RIPv1                                                | RIPv2                                                  |
| ---------------------------------------------------- | ------------------------------------------------------ |
| 서브넷 마스크 정보가 없는(classful) 라우팅 정보 전달 | 서브넷 마스크 정보가 포함된(classless)라우팅 정보 전달 |
| 전송시 브로드캐스트 주소 사용                        | 전송시 멀티캐스트 주소 사용                            |
| auto summary를 막을수없다                            | auto summary 방지 가능                                 |
RIPv1
```
AS : 자체 시스템, 인터넷 상의 라우터들과 서브네트워크 들의 집합
IGP : AS내 에서 사용하는 라우팅 프로토콜
EGP : AS 간 통신에 사용하는 라우팅 프로토콜
디스턴스 벡터 : 인접한 라우터에서 경로 정보를 습득
링크 스테이트 : 라우터에 연결된 링크 상태를 서로 교환 하여 각 네트워크 맵(토폴로지 구성)을 그림.
```
#### Distance-vector의 문제 (Looping) 해결
1. Maximum Hop count<br>라우터의 최대 홉 카운트는 15이다. 16부터는 라우팅이 되지 않는 것을 이용하는 것.<br> => 대규모 망에서는 홉이 많기 때문에 사용안함.
2. Hold Down Timer<br>어떠한 경로가 Down 상태일 경우. 테이블 값을 바로 변경하지 않고 *일정 시간* 이 지난 후에 변경하는 것. <br>=> 일정시간이란, 모든 라우터에 해당 경로가 down되었다는것을 인식한 시간
3. Split Horizon<br>두 라우터 간에 루핑만을 막아주기 위한 기술.
자신 보다 메트릭값이 큰 네트워크의 정보를 보내준 라우터에 정보 송신시 해당 네트워크에 대한 정보를 보내지 않는다.
4. Route Poisoning<br>라우터가 한 네트워크가 다운 되었을 경우, 메트릭 값을 변경하여 사용할 수없게 만드는 것이다. <br>즉, 다운된 네트워크를 무한 대치상태로 바꾸어 라우팅 테이블에서 지운후, 잘못된 라우팅 정보를 받는 일을 사전에 방지
5. Poison Reverse<br>라우팅 정보를 보내온 쪽으로 되돌려 보낼때 이값을 최대치로 쓴다.
### 라우터 경로 찾기 tracert(cisco)
``tracert 목적지IP``<br> 목적지 IP로 가는 경로들의 게이트웨이의 목록을 보여준다.<br>TTL 값을 1로 시작하여 1개씩 증가 시켜 홉들간에 연결상태를 추적하여 경로를 찾을수있다.

### OSPF (Open Shortest Path First)
#### 1.1 개요
- SPF(Dijkstra 알고리즘)에 기초한 IGP를 디자인 하기 위해 형성됨.
- 대규모 네트워크나 성장하는 네트워크를 위해 고안됨. (Distance vector의 한계를 극복)
#### 1.2 장점
```
1. Fast Convergence
	convergence time? 라우터간의 서로 변경된 정보를 주고 받는 것.
	RIP의 경우는 30초마다 업데이트 하지만 OSPF는 변경 시 즉시 전달하기때문에 빠름
2. VSLM 지원
3. 네트워크 크기
	RIP의 최대 홉수는 15이지만 OSPF는 제한없음
4. Bandwidth(대역폭)의 효율성
	RIP는 30초 주기로 브로드캐스트가 발생하지만, OSPF는 변화시에만 정보를 전달(멀티캐스트)하므로 효율적
5. 경로 설정
	RIP는 오직 홉카운트만으로 최적의 경로를 계산한다.(속도,딜레이지연 고려x)
	OSPF는 많은 요소(cost)를 고려하여 최적의 경로 계산'
6. 라우팅 메시지 인증 지원
7. 메트릭이 동일한 여러 경로가 있을 때, 로드밸런싱 가능
```
#### 1.3 AREA
**AREA**
- OSPF에서 네트워크를 여러 AREA로 나누고 라우팅 정보를 몇가지로 구분하여 작은 라우팅 테이블을 구현
- AREA 0 (중심이 되는 AREA)가 있어야 하며 다른 AREA들은 AREA 0 과 붙어있어야함. (아닐경우 , 가상링크(Virtual Link)를 통해 연결)

| 이름                                      | 특징                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| IR<br>(Internal Router)                   | AREA내에 포함되어있는 라우터를 IR                            |
| ABR<br>(Area Border Router)               | AREA와 AREA의 경계에 있는 라우터를 ABR<br>ABR은 적어도 하나의 인터페이스가 AREA 0 에 속해야함. |
| ASBR<br>(Autonomous System Border Router) | 라우터의 인터페이스 중 일부가 OSPF영역 밖에 있는 경우의 라우터를 ASBR<br>RIP과 OSPF는 다른 프로토콜이므로 재분배 해야할 경우 해당 |


#### 라우터 내부

```
control plane : routing table,link state database, neibor table
data plane : Forwarding table
```

#### OSPF 설정
```
프로세스 작동(PID 설정)
OSPDF로 전달할 network 정보를 선언 (network 주소 wildcardmask크기  area ID)
AD value(관리거리 값) :110
metric : cost(계산된 bandwidth)

```



### ACL (Access Control List)
host,network에 대해 접근 목록(allow, permit)/거부(deny)에 대한 정책들의 목록

#### 방법
```
1. 정책을 만듦(여러 정책을 하나의 그룹으로 묶음)
2. 만든 정책을 interface에 적용함(in/out)
```

정책을 만들 조건에 따라
- 표준(Standard) ACL
누가(src addr)
- 확장(Extended ACL)
누가,어디로,무엇때문에(목적)(src/dst , ip/port)

### 라우터 IP 주소 할당(cisco)

```linux
Router> en // 관리자 모드로 전환
Router# conf t
Router(config)# hostname GW // 이름변경
GW(config)# int fa 0/0
GW(config-if)# ip address 0.0.0.0 255.255.255.255 // IP와 서브넷마스크 할당
GW(config-if)# no shutdown // shotdown이 기본설정인데 이걸 해제 -> 라우터 켜짐
GW(config-if)#end // 빠져나옴
GW# show run // 입력한 명령어 확인
GW# wr //저장
GW# ping 192.168.0.1~ // end device 까지 핑테스트
GW# show ip int brief // 인터페이스 확인
GW# show ip route // 라우팅 테이블 확인
```
