# 1. 네트워크 통신 
## 1.1 데이터 전송 방식
- 유니캐스트 (Unicast)
```
1:1 통신 
출발지와 목적지가 1:1로 통신

실제로 사용하는 대부분의 통신
```
- 브로드캐스트 (Broadcast)
```
1: 모든 통신
동일 네트워크에 존재하는 모든 호스트가 목적지

유니캐스트 통신전 상대방의 정확한 위치를 찾기 위해 사용.
주소 체계에 따라 다양하게 분류할 수 있지만 기본 동장은 로컬 네트워크내에서 모든 호스트에 패킷을 전달 시 사용.
```
- 멀티캐스트 (Multicast)
```
1: 그룹
하나의 출발지에서 다수의 특정 목적지로 데이터 전송.

그룹 주소를 이용해 해당 그룹에 속한 다수의 호스트로 패킷을 전송함.
단방향으로 다수에게 동시에 같은 내용을 전달할 때 사용.
```
- 애니캐스트 (Anycast)
```
1:1 통신(목적지는 동일 그룹 내의 1개 호스트)

주소가 같은 호스트들 중에서 가장 가깝거나 가장 효율적으로 서비스할 수있는 호스트와 통신.
가장 가까운 DNS 서버를 찾을 때 사용하거나 가장 가까운 게이트웨이 기능에 사용하기도 함.
```


## 1.2 MAC 주소

Media Access Control의 줄임말.

L2에서 통신을 위해 네트워크 인터페이스에 할당된 식별자.

네트워크에 접속하는 **모든 장비**는 MAC주소라는 물리적 주소가 있어야함.

### 1.2.1 주소 체계
MAC주소는 변경할 수 없도록 하드웨어에 고정되어 출하.

48비트의 16진수 12자로 표현.

> 00 00 00 / 00 00 00

앞의 24비트는 제조사 코드(Vender Code)인 **OUI**
뒤의 24비트는 제조사에서 자체적으로 할당하는 **UAA**

MAC 주소를 BIA(Burned-In Address)라고도 함.
> - MAC 주소가 유일 하지 않을 수도 있는데, 동일 네트워크에서만 중복되지 않으면 동작하는 데 문제 없다.
>
> - 네트워크 통신 시, 네트워크가 달라 라우터의 도움을 받아야 할 경우 라우터에서 다른 네트워크로 넘겨줄 때 출발지와 도착지의 MAC주소가 변경되므로 네트워크를 넘어가면 기존 출발지와 도착지 MAC주소를 유지하지 않는다.
### 1.2.2 MAC 주소 동작
NIC는 자신의 MAC 주소를 가지고 있고 전기 신호가 들어오면 L2에서 패킷으로 변환하여 내용을 구분하고 도착지 MAC주소를 확인함.
만약, 도착지의 MAC주소가 다르면 해당 패킷 폐기.
패킷의 목적지가 자기 자신이거나 브로드캐스트,멀티캐스트와 같은 그룹 주소라면 처리해야할 것으로 판단하여 상위 계층(네트워크 계층,L3)으로 전달.

### 1.2.3 참고



## 1.3 IP 주소
사용자가 변경 가능한 논리 주소.

주소에 레벨이 있다. 그룹을 의미하는 **네트워크 주소**와 **호스트 주소**로 나뉜다.

><pre>네트워크 주소 : 호스트들을 모든 네트워크를 지칭하는 주소
>	 	 	 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 함.
>호스트 주소 : 하나의 네트워크 내에  존재하는 호스트를 구분하기 위한 주소
></pre>
>### 1.3.1 클래스  기반(Classful) 네트워크
>확장성이 있으며 주소 낭비가 적은 최적의 조건을 만들수 있다.
>서브넷 마스크가 필요없다.
| 클래스 | 주소 범위     | 서브넷 마스크 |
| ------ | ------------- | ------------- |
| A      | 1~127.0.0.0   | 255.0.0.0     |
| B      | 128~191.0.0.0 | 255.255.0.0   |
| C      | 192~223.0.0.0 | 255.255.255.0 |

현재는 클래스 기반으로 네트워크를 분할 하지않는다. 

### 1.3.2 클래스리스 네트워크
#### 1.3.2.1  클래스리스 등장 배경
~~~
IPv4의 가장 큰 문제는 주소 자체의 부족도 있지만 상위 클래스(A클래스)를 할당 받은 조직에서 이 주소들을 제대로 활용하지 못해 낭비하는 것이였음.

클래스풀에서는 한개의 클래스 네트워크가 한 조직에  할당되면 아무리 비어 있는 주소라도 IP를 분할하여 다른 기관이 사용할수 없었다.
~~~
이러한 문제를 해결 하기 위해 클래스 개념을 버리게 된다.
#### 1.3.2.2 클래스리스 개요
네트워크와 호스트 주소를 나누는 구분자를 사용하는데 **서브넷 마스크**를 사용
~~~
서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용하는데,
2진수 숫자 1 : 네트워크 주소
2진수 숫자 0 : 호스트 주소
보통 편하게 받아드릴수 있게 10진수를 사용해 
255.0.0.0 , 255.255.0.0 , 255.255.255.0로 표현 한다.
255는 네트워크 주소 부분, 0은 호스트 주소 부분
~~~
네트워크 주소 구하기
~~~
호스트 주소 : 103.9.32.146
서브넷 마스크 : 255.255.255.0

네트워크 주소 : 103.9.32.0

호스트 주소와 서브넷 마스크를 &연산하여 네트워크 주소를 구한다.
~~~

클래스리스 기반의 IP네트워크는 네트워크를 표현하는데 반드시 서브넷 마스크가 필요하고 서버나 PC에 IP주소를 부여할 때도 사용되어야 함.

### 1.3.3 서브네팅(Subnetting)
원래 부여된 클래스의 기준을 무시하고 새로운 네트워크-호스트 구분 기준을 사용자가 정해 원래 클래스풀 단위보다 더 쪼개 사용하는 것.
> 서브네팅에 대해 고민해야 하는 경우
>  - 네트워크 디자인 단계에서 네트워크 설계자가 네트워크를 효율적으로 어떻게 분할할것인지 계획하는 경우
>  > 네트워크 설계시 네트워크 내 필요한 단말을 고려한 네트워크 범위 설계
>  - 이미 분할된 네트워크에서 사용자가 자신의 네트워크와 원격지 네트워크를 구분해야하는 경우
>  > 네트워크에서 사용할 수 있는 IP범위 파악
>  > 기본 게이트웨이와 서브넷 마스크 설정이 제대로 되어있는지 확인

#### 1.3.3.1 