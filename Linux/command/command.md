

# 5.3


## ls

## cat     //파일 정보 보기
  -n 라인 넘버 보기
## tail , head  // 파일 정보 보기
  -num 밑에서부터 10줄 보기
  +num 10번째 줄부터 다 보기 //head에는 없다

> head와 tail을 적절히 사용하여 원하는 부분만 볼수있다.
> cat -n aaa | head -20 | tail -11 //10번째 줄부터 20번째줄까지 보기

> cat -n aaa | head -20 | tail +10 // 10번째줄부터 20번째 줄까지 보기

## grep
// 파일 내용을 특정 패턴(키워드?)로 검색기능
``grep option pattern filename``
종류 fgrep, egrep
|명령어|설명|
|--|--|
|-i|검색 패턴 대소문자 구분 무시|
|-l|매칭 되는 패턴이 있는 파일 이름 출력|
|-n|매칭되는 줄번호 표시|
|-c|검색 패턴과 매칭되는 줄 갯수 출력|
|-v|검색 패턴을 제외하고 출력|

> ``grep -ls /dev | grep ^s`` /dev 밑에 소켓 파일 보기

정규화 표현식
|메타 문자|용도|예제|결과|
|--|--|--|--|
|^|줄의 시작|^root|root로 시작하는 줄|
|$|줄의 마지막|root$|root로 끝나는 줄|
|.|한문자 대치|s...s|s로시작하고 s로 끝나며 중간에 아무거나 3개|
|*|아무것도 없거나 여러 문자 대치|[a-z]*|소문자로 시작하는 모든문자 or 아무것도 없음|
|[]|패턴중 한 문자 일치|[Rr]oot|Root또는 root|
|[^]|패턴중 제외할 문자|[^a-r]oot|첫문자가 a에서 r까지 제외하고 s에서 z까지오는 문자|

>[a-z][A-Z]은 모든 알파벳을 표현 => ::alpha:: 로 대치 가능
> [0-9] 숫자의 표현

fgrep
정규표현식에서 사용된 특수문자가 파일에 있을 경우 그 표현식이 해당하는 것을 찾기 위해 사용
> 정규표현식에 사용되는 특수문자를 메타문자로 인식하지않고 문자열로 인식


### >과 >>
표준 입력
\> 명령어 뒤에 나오는 파일에 덮어쓸때 사용 (overwrite)
\>> 명령어 뒤에 나오는 파일에 추가 할때 사용 (append)
> 표준 출력은 기본적으로 /dev/pts/본인터미널
> tty로 확인 가능하다
> `cat  > /dev/pts/본인 터미널`이 생략 되있는것이다, 출력을 다른 터미널에 할수있음.

cat < aa > b  //aa의 표준 입력을 b에다가 씀

touch
파일을 생성할수있지만 시간을 변경할수있다. 새로운 파일을 만들수 있지만 이미 있는 파일을 touch명령어로 사용한다면 파일의 사용시간이 최신화 되기때문에 보안적 측면에서 좋지않다.(무결성 훼손가능)

#### 파일 디스크터
```
파일 디스크립터 테이블의 인덱스이다.

파일 오픈 or 소켓 생성 시 부여(3부터 시작) 가장 작은 값부터 할당됨.

프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근시, FD값을 이용해 파일을 지칭할수있다.

시스템이 만들어 놓은것을 가리키기 좋게 하기 위해 시스템이 우리들에게 건네주는 숫자일 뿐이다.
```
default는 1
1> 표준 출력
2> 표준 에러
```bash
ls -l 2> /dev/pts/2
에러 메세지는 2번 터미널로 출력하고 정상적으로 수행시 현재 터미널로 출력

ls -l 1> /dev/pts/2
에러메세지는 현재터미널 정상적으로 수행되면 2번 터미널로 출력
```
0,1,2는 예약된 번호로 3부터는 커스터마이징할수있다.

## mkdir
디렉토리 새로 생성
`mkdir dir1` 하지만 ``mkdir dir1/dir2``는 안됨.
디렉토리밑에 하위 디렉토리까지 같이 생성하려면 `-p`
``mkdir -p dir1/dir2``


## rm
파일 삭제시
``rm 파일`` -i 명령어 추가하면 삭제 여부 물어봄
디렉토리 삭제는 불가함
rmdir
디렉토리 삭제
``rmdir 디렉토리명`` 빈 디렉토리만 삭제 가능하며 비어있지 않는 디렉토리는 ``rmdir -r 디렉토리명``
마찬가지로 -i추가시 삭제여부 물어봄.



## vi 편집기
1. 삭제
dd

2. 복사
yy
3. 잘라내기
cc
4. 붙여넣기
p

단어 치환
`:%s/old/new/g` -> `:%s/usr/root/g` vi내에서 usr를 root로 모두 치환.

vi로 여러개 열었을때
``vi aaa bbb`` :n 뒤에있는파일, :N앞에있는 파일로 이동



## FILE I/O command
### cut
간격이 일정한 라인을 잘라서 사용할때 용이
```bash
cut -csdf 파일이름
```

|옵션|설명|
|--|--|
|c|문자수로 열을 계산해서 출력<br>ex_ cut -c 2-4 data|
|s|필드 구분자를 사용|
|d|파일 내의 필드로 따져서 추출|
|f| filed|


### paste
파일 여러개로 합쳐서 새로운 결과 데이터를 만드는것 <br>
cut같은것을 유용하게 사용
```bash
paste -sd 파일이름1 파일이름2
```
| 옵션     | 설명     |
| :------------- | :------------- |
| s     | 수직으로 보여지는 결과를 수평으로 바꿀수있다 파일간에 줄바꿈|
|d| 두 파일을 합칠때 구분자를 정의 가능 <br> paste -d : file1 file2 |

### sort
디폴트값은 첫번째 필드를 기준으로 오름차순 정렬이다.
```bash
sort -frbktn 파일이름
```

|옵션|설명|
|--|--|
|f|대소문자를 구분하지 않음|
|r|내림차순으로 정렬|
|k|필드 번호를 표시한다.<br>sort -k3 file1<br>3번째 필드를 표시|
|t|필드 구분자로 사용한다. <br>cut -d 를 표시|
|n|필드의 첫번째 기준을 정렬을 하는데 숫자일 경우 90 100 일경우 9,1로 정렬한다.<br> 이것을 숫자로 비교하게 해준다.|


### sed
```bash
sed 's/old/new/g' data
sed 'n,ms/old/new/g' data
vi 편집기와 유사하다.
```
|옵션|설명|
|--|--|
|p|행을 출력 n과 함께 사용할경우 선택된 행만 출력|
|d|선택한 항 삭제|
|-e|다중 편집 지원<br>여러개의 ''가 사용된다면 모두 앞에 -e를 붙여준다.|
|q|sed 종료 <br>ex_ sed '4q' data (4번째 줄까지만 출력하고 종료됨)|

### awk
공백을 알아서 구분해주기때문에 조건문을 포함해서 사용하면 강력히 사용할수있다.
```bash
awk '$2 > 24 {print $1"씨는"$2"세 입니다"}'
```


### ps

### tar
