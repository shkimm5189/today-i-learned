# 리눅스

## 1. Inode


## 2. Link (Symbolic, Hard)
|구분|하드 링크|심볼릭링크|
|--|--|--|
|생성 명령어|ln 원본파일 링크파일|ln -s 원본파일 링크파일 |
|생성 종류|파일만 생성|디렉토리,파일 생성|
|링크 기능|원본파일(inode)에 대한 포인터|파일/디렉토리 이름에 대한 링크를 가리킴|
|원본 파일 삭제 시|액세스 가능|액세스 불가|
|Inode 번호|inode 같음|inode 다름|
|용량|추가적인 용량 없음|추가 용량 차지|
|다른 파티션 링크|다른 파티션에 링크 불가|다른 파티션에 링크 가능|

> 링크된 파일에서 내용을 수정해도 그 내용이 원본 파일에 똑같이 반영됨<br>
> > 모든 링크를 하드 링크로 사용하지 않을까 ???
> 파티션을 나눠 관리할경우 하드링크의 경우 링크가 깨지기때문에 심볼릭 링크가 적절할수있다.

### 2.1 링크 사용시기
**심볼릭 링크**
1. 서로 다른 파티션(파일 시스템)에 링크할 경우 사용
2. 디렉토리를 링크할 경우 사용


**하드 링크**
1. 저장 공간 : 하드링크는 진짜로 데이터를 복사한게 아니라 이미 존재한 데이터의 위치만 가리키기에 용량 차지 하지않음.
2. 성능 : 다른 파일을 거치지 않으므로 성능이 약간 좋음.
3. 파일 위치 이동 : 같은 파일 시스템 내에서 다른 위치로 옮기면 하드링크는 동작하지만 소프트링크는 실패
4. 안전성 : 심볼릭 링크보다 데이터 안전성이 우수



## 3. Permission
|퍼미션|문자|파일 |디렉토리|
|--|--|--|--|
|read|r|내용 확인 / 복사 가능|디렉토리 내용 확인 가능 (ls)|
|write|w|파일 내용 수정 가능|실행 권한이 있을 경우 디렉토리내 파일 추가 및 삭제 가능|
|execute|x|실행 파일일 경우 실행가능<br>쉘 스크립트의 경우, r-x권한이 있으면 실행가능|cd 명령어로 접근가능. r권한이 있을경우 ls -l 디렉토리 내용 확인 가능|

> 디렉 토리에 실행 권한만 없을경우(rw-) 해당 디렉토리내 파일 추가/삭제가 가능 한가?
디렉토리에 읽기 권한만 없을경우(-wx) ls -l 가능 한가?

### 3.1 리눅스 read, write, execute (rwx)
**file rwx**
- **read**
file의 data block을 통해 실제 디스크의 데ㅐ이터 섹터로 접근 후 그 내용을 표준 출력 or 지정된 터미널로 출력

- **write**
file의 data block을 통해 실제 디스크의 데이터 섹터 접근후 표준 입력 or 데이터를 접근 한 섹터에 write 하는 과정

- **execute**
file의 data block을 통해 접근한 데이터 섹터의 파일 내용에 access하는 것
<br>

**directory rwx**

- **read**
directory의 data block을 통해 실제 디스크의 데이터 섹터로 접근 후 그 내용을 표준 출력 or 지정된 터미널로 출력

- **write**
directory의 data block을 통해 실제 디스크의 데이터 섹터 접근후 표준 입력 or 데이터를 접근 한 섹터에 write 하는 과정

- **execute**
directory의 data block을 통해 접근한 데이터 섹터의 파일 내용에 access하는 것

read : cat head tail ls<br>
write : mkdir > >> touch cp mv rm rmdir<br>
exxecute : cd<br>


### 3.2 chmod
r(4)w(2)x(1)로 부여가능
- 8진수 모드
``rwx/rwx/rwx  = user/group/others``
``chmod 777 test1``

- 심볼릭 모드
``chmod "mode" test1``


|옵션|설명|
|--|--|
|ugoa|u = user<br>g = group <br>o = others<br>a = all|
|+-=|+ 권한 추가<br>- 권한 삭제 <br> = 입력된 권한만 추가 (입력 안된 권한들은 삭제된다.)|
|rwx|read write execute|

> chmod로 심볼릭 링크와 시스템 콜의 권한을 바꿀수 없다.


## 3.3 UMASK
#### 3.3.1 개요
- XOR 연산을 통해 계산된다.
- 파일이나 디렉토리에 생성시 default Permission을 부여하기 위해서 존재한다. 보안적으로나 관리적인 측면에서 사용을편하게 하기 위해서이다.
- 스페셜 퍼미션은 지정할수없다.
- 터미널에서 지정된 umask는 해당 터미널에서만 사용됨.(휘발성)

특정 사용자의 umask를 영구적으로 지정하려면 사용자의 bash_profile에서 umask값을 지정해야함<br>
파일의 Full Permission = 666 <br>

> 파일의 실행 권한을 뺀이유 : 파일안에 어떤 명령어,위험한 명령어 등이 있을경우 위험하기때문이다(ex. rm -rf /.). 뭐가 들어있는줄알고 실행시킴?

디렉토리의 Full Permission = 777

#### 3.3.2 사용
umask를 지정하는 방법은 chmod와 동일하다.<br>
- 심볼릭모드 : chmod와 사용법이 똑같다
- 숫자모드 : 최대권한(umask적용이 안된 Full Permission)에서 umask 지정값을 빼면된다.

``umask -S``현재 지정된 umask를 심볼릭 모드로 모여준다.<br>
``umask 0655``umask 지정``umask 4`` 아규먼트가 한개,두개일경우 뒤에서부터 권한이 지정.


## 3.4 고급 권한
|종류|사용|내용|
|--|--|--|
|set uid|u+s|실행 권한이 있는 바이너리 파일/스크립트 파일만 사용|
|set gid|g+s||
|sticky bit|o+t||

1. Set Uid
- 바이너리 파일이나 스크립트 파일에 적용
- 실행한 사용자가 아닌 파일 소유자의 권한으로 실행
- user의 실행 권한이 x대신 s로 표시됨.

```
root 권한이 필요없는 프로그램에 소유주가 root로 되어있고 setuid가 설정되있을경우 보안적으로 매우 취약
일반 사용자로 접근하는 경우도 root로 실행이 가능해지기 때문
권한 상승의 문제 때문에 setuid설정은 최소화 해야한다.
```
> S와 s의 차이?? 실행권한의 유무의 차이이다.

> chomod u-s와 chmod u+s의 차이점 확인
/etc/passwd 파일의 경우 소유자가 root이므로 일반 사용자가 passwd명령어를 사용하더라고 파일의 소유자의 root권한으로 실행된다 하지만 s를 제거할경우 일반 사용자의 권한으로 파일이 실행되고 비밀번호는 바뀌지 않는다.


2. Set Gid
- 바이너리 파일이나 스크립트 파일에 적용할수있지만 일반적으로 디렉토리에 설정해놓고 사용하는 경우가 많다.
- 주로 데몬 프로세스가 사용하는 그룹의 권한을 공유하기 위해 사용


3. Sticky bit
- 디렉토리에 기타 사용자 권한이 rwx인 경우 모든 사용자가 해당 디렉토리에서 파일 생성 및 삭제 가능
- 특정 디렉토리를 누구나 자유롭게 사용하고자 할때 사용
- 단, 읽기나 쓰기는 문제가 되지 않을수있지만 삭제나 변경시 문제가 될수있기때문에 sticky bit가 설정되어있다면 이를 막을수있다.

> sticky 비트를 공유 모드라 함. 

## 4. File Descriptor FD
- 파일 디스크립터 테이블의 인덱스이다.
- 파일 오픈 or 소켓 생성 시 부여(3부터 시작) 가장 작은 값부터 할당됨.
- 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근시, FD값을 이용해 파일을 지칭할수있다.
- 시스템이 만들어 놓은것을 가리키기 좋게 하기 위해 시스템이 우리들에게 건네주는 숫자일 뿐이다.



## 5. 프로세스


## 사용자 및 그룹 관리
